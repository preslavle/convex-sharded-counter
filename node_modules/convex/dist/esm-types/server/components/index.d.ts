import { ObjectType, PropertyValidators } from "../../values/index.js";
import { AnyFunctionReference, FunctionReference, FunctionType } from "../api.js";
import { DefaultFunctionArgs, EmptyObject } from "../registration.js";
export declare const toReferencePath: unique symbol;
export declare function extractReferencePath(reference: any): string | null;
export declare function isFunctionHandle(s: string): boolean;
export type FunctionHandle<Type extends FunctionType, Args extends DefaultFunctionArgs = any, ReturnType = any> = string & FunctionReference<Type, "internal", Args, ReturnType>;
export declare function createFunctionHandle<Type extends FunctionType, Args extends DefaultFunctionArgs, ReturnType>(functionReference: FunctionReference<Type, "public" | "internal", Args, ReturnType>): Promise<FunctionHandle<Type, Args, ReturnType>>;
interface ComponentExports {
    [key: string]: FunctionReference<any, any, any, any> | ComponentExports;
}
export interface InitCtx {
}
/**
 * An object of this type should be the default export of a
 * component.config.ts file in a component definition directory.
 *
 */ export type ComponentDefinition<Args extends PropertyValidators = EmptyObject, Exports extends ComponentExports = any> = {
    /**
     * Install a component with the given definition in this component definition.
     *
     * Takes a component definition, an optional name, and the args it requires.
     *
     * For editor tooling this method expects a {@link ComponentDefinition}
     * but at runtime the object that is imported will be a {@link ImportedComponentDefinition}
     */
    install<Definition extends ComponentDefinition<any, any>>(definition: Definition, options: {
        name?: string;
        args?: ObjectType<ComponentDefinitionArgs<Definition>>;
    }): InstalledComponent<Definition>;
    installWithInit<Definition extends ComponentDefinition<any, any>>(definition: Definition, options: {
        name?: string;
        onInit: (ctx: InitCtx, args: ObjectType<Args>) => ObjectType<ComponentDefinitionArgs<Definition>>;
    }): InstalledComponent<Definition>;
    mount(exports: ComponentExports): void;
    /**
     * Mount a component's HTTP router at a given path prefix.
     */
    mountHttp(pathPrefix: string, component: InstalledComponent<any>): void;
};
type ComponentDefinitionArgs<T extends ComponentDefinition<any, any>> = T["__args"];
type ComponentDefinitionExports<T extends ComponentDefinition<any, any>> = T["__exports"];
/**
 * An object of this type should be the default export of a
 * app.config.ts file in a component definition directory.
 *
 */
export type AppDefinition = {
    /**
     * Install a component with the given definition in this component definition.
     *
     * Takes a component definition, an optional name, and the args it requires.
     *
     * For editor tooling this method expects a {@link ComponentDefinition}
     * but at runtime the object that is imported will be a {@link ImportedComponentDefinition}
     */
    install<Definition extends ComponentDefinition<any, any>>(definition: Definition, options: {
        name?: string;
        args?: ObjectType<ComponentDefinitionArgs<Definition>>;
    }): InstalledComponent<Definition>;
    mount(exports: ComponentExports): void;
    /**
     * Mount a component's HTTP router at a given path prefix.
     */
    mountHttp(pathPrefix: string, component: InstalledComponent<any>): void;
};
/**
 * Used to refer to an already-installed component.
 */
declare class InstalledComponent<Definition extends ComponentDefinition<any, any>> {
    constructor(definition: Definition, name: string);
    get exports(): ComponentDefinitionExports<Definition>;
}
export type ImportedComponentDefinition = {
    componentDefinitionPath: string;
};
export declare function defineComponent<Args extends PropertyValidators = EmptyObject, Exports extends ComponentExports = any>(name: string, options?: {
    args?: Args;
}): ComponentDefinition<Args, Exports>;
/**
 * Experimental - DO NOT USE.
 */
export declare function defineApp(): AppDefinition;
type AnyInterfaceType = {
    [key: string]: AnyInterfaceType;
} & AnyFunctionReference;
export type AnyComponentReference = Record<string, AnyInterfaceType>;
type AnyChildComponents = Record<string, AnyComponentReference>;
/**
 *
 */
export declare function createComponentArg(): (ctx: any, name: string) => any;
/**
 */
export declare const appGeneric: () => AnyChildComponents;
/**
 */
export type AnyApp = AnyChildComponents;
/**
 */
export declare const componentGeneric: () => AnyChildComponents;
/**
 */
export type AnyComponent = AnyChildComponents;
export {};
//# sourceMappingURL=index.d.ts.map